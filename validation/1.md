### Coupled Services

When a single service become responsible for handling multiple unrelated concerns, they introduce tight coupling. This violates the principle of **Separation of Concerns** and makes the service difficult to maintain, test, or reuse.  

In the example below, the `AppService` handles both user and item logic, and is injected into components with unrelated responsibilities.

```ts
@Injectable({ providedIn: 'root' })
export class AppService {
  getUser() { /* ... */ }
  getItems() { /* ... */ }
}

@Component({ /* ... */ })
export class HeaderComponent {
  user = this.appService.getUser();
  constructor(private appService: AppService) {}
}

@Component({ /* ... */ })
export class ListComponent {
  items = this.appService.getItems();
  constructor(private appService: AppService) {}
}
```

### Direct DOM manipulation

In web development, the Document Object Model (DOM) represents the structure of a web page as a tree of objects that can be programmatically accessed and modified. As usual in **Angular**, developers can access DOM elements through the `ViewChild` decorator and manipulate them using the `ElementRef` class. While this approach may seem convenient, it bypasses Angular's declarative and reactive paradigms.  

In the example below, the `ElementRef` is used to directly alter an element's style:

```ts
@Component({
  selector: 'app-alert',
  template: `<div #alertBox>Alert message</div>`
})
export class AlertComponent {
  @ViewChild('alertBox') alertBox!: ElementRef;

  ngAfterViewInit() {
    this.alertBox.nativeElement.style.backgroundColor = 'red';
  }
}
```

### Prop drilling

**Prop Drilling** arises when data must be passed from a parent component to a deeply nested child component through multiple intermediary components that do not use the data themselves. This smell typically occurs through successive declarations of `@Input` properties, resulting in tightly coupled component hierarchies and reduced maintainability.

Consider a scenario where the `ParentComponent` holds an object named `data`, intended solely for use in `ChildComponentC`. However, since `ChildComponentC` is nested within `ChildComponentB`, which in turn is nested in `ChildComponentA`, the `data` must be passed through each intermediary component via `@Input()` bindings, even though none of them utilize it directly.  

Furthermore, the inverse can occur when a deeply nested child component needs to emit an event to its ancestor. In this case, multiple intermediary components must define `@Output()` event bindings to propagate the emitted event upward in the hierarchy.

### Large file

In Angular, large files commonly emerge when developers embed templates directly within component classes using inline templates, combine multiple service implementations, or co-locate related but distinct functionalities without proper separation. This anti-pattern violates the principle of single responsibility at the file level, creating monolithic structures that become increasingly difficult to navigate and modify as the codebase evolves.