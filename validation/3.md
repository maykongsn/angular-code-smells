### Duplicated component

**Duplicated Component** manifests when multiple Angular components within a project share highly similar or identical structure, logic, or functionality. Consequently, such duplication leads to redundancy in the codebase. Furthermore, the presence of duplicated components suggests insufficient abstraction and poor reuse of common functionalities.

### Inheritance instead of composition

While Angular supports both inheritance and composition, some developers heavily rely on class inheritance to share logic across components, often by creating abstract base classes. However, this approach can introduce tight coupling between components and reduce maintainability.  

As illustrated in the example below, a base class encapsulates shared functionality:

```ts
export abstract class BasePageComponent {
  abstract pageTitle: string;

  initPage() {
    console.log(`Initializing page: ${this.pageTitle}`);
  }
}

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html'
})
export class HomeComponent extends BasePageComponent {
  pageTitle = 'Home Page';
}
```

Moreover, developers report that subclasses frequently require behavior not anticipated in the base class, leading to abstract methods tailored to specific cases. This results in logic being spread across the hierarchy, which hampers modularity, flexibility, and ease of testing.

### Inefficient method binding in templates
Angular provides two main change detection strategies to manage how and when the view is updated in response to state changes: The Default strategy, which checks the entire component tree, and the OnPush strategy, which limits checks to components with changed inputs or triggered events.

```tsx
<div>
    <p>Total: {{ calculateTotal() }}</p>
</div>
```

```tsx
@Component({
  selector: 'app-cart',
  templateUrl: './app-cart.component.html'
})
export class CartComponent {
  items = [{ price: 10 }, { price: 15 }, ...];

  calculateTotal(): number {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

A commonly reported case by the practitioners involves binding methods directly in templates under the default strategy. In the above example, _calculateTotal()_ is re-evaluated every time Angular runs change detection, even if item is not changed. This happens because the framework does not cache the return value of the method, as it is not a pure function. Since Angular cannot determine whether the method is free of side effects or consistently returns the same output, it executes the method on every cycle to ensure correctness.