### Overusing Any Type

In Angular, developers tend to use the type any, a type annotation that effectively disables type checking, allowing a variable to accept any value without restrictions. When a variable is declared with any, the TypeScript compiler bypasses type verification, providing maximum flexibility while eliminating the fundamental benefits of static typing.

Practitioners report that excessive use of the any type compromises type safety, one of TypeScript's primary advantages, allowing type errors to pass undetected during compilation and manifest only at runtime. Additionally, extensive use of any can mask design and architectural issues, creating a false sense of simplicity that results in more fragile and error-prone code.

```tsx
@Component({
  selector: 'app-user-profile',
  templateUrl: './app-user-profile.component.html'
})
export class UserProfileComponent {
  user: any;
  users: any[] = [];
  
  constructor(private userService: UserService) {}
  
  loadUser(id: any): void {
    this.userService.getUser(id).subscribe((data: any) => {
      this.user = data;
      this.processUserData(data);
    });
  }
}
```

### Excessive parent-to-child communication

Component-based architectures encourage a modular and decoupled structure where communication between components occurs through well-defined and constrained mechanisms. However, some developers report the excessive use of `@ViewChild`, a feature that allows a parent component to access a child component's public interface directly, as a source of architectural degradation.

This anti-pattern introduces a strong dependency between the parent and the internal implementation of the child. As a result, changes to the child component may propagate to the parent, as in the example below:

```ts
@Component({
  selector: 'app-child',
  template: `<p>{{ message }} - {{ count }}</p>`
})
export class ChildComponent {
  message = 'Init';
  count = 0;

  update(msg: string) {
    this.message = msg;
    this.count++;
  }

  reset() {
    this.message = 'Init';
    this.count = 0;
  }

  /* ... */
}

@Component({
  selector: 'app-parent',
  template: `
    <app-child></app-child>
    <button (click)="init()">Init</button>
    <button (click)="activate()">Activate</button>
    <button (click)="disable()">Disable</button>
    <button (click)="increment()">Increment</button>
    <button (click)="reset()">Reset</button>
  `
})
export class ParentComponent {
  @ViewChild(ChildComponent) child!: ChildComponent;

  updateChild() {
    this.child.update('Updated by parent');
  }

  resetChild() {
    this.child.reset();
  }

  /* ... */
}
```

The parent directly alters the child's state by invoking its method. This implementation compromises component independence and hinders unit testing, as child components can no longer operate in isolation. Moreover, this tight coupling may escalate over time, leading to rigid component hierarchies.

### Large component

A large component refers to a component that contains excessive code, handles multiple responsibilities, or encompasses too many features, violating the single responsibility principle. The developers advocates for component decomposition as a fundamental practice, where complex or reusable UI portions should be extracted into separate, focused components.

### Too many inputs

The `@Input` decorator is used to define properties that allow a child component to receive data from its parent. However, relying on an excessive number of external inputs can be problematic. It often indicates that the component is overly complex or tightly coupled to its parent, which undermines modularity.

```ts
@Component({
  selector: 'app-user-card',
  templateUrl: './user-card.component.html'
})
export class UserCardComponent {
  @Input() userName!: string;
  @Input() userAge!: number;
  @Input() userEmail!: string;
  @Input() userRole!: string;
  @Input() isActive!: boolean;
  @Input() showAvatar!: boolean;
  @Input() highlight!: boolean;
  /* ... */
}
```